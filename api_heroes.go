/*
OpenDota API

# Introduction The OpenDota API provides Dota 2 related data including advanced match data extracted from match replays.  You can find data that can be used to convert hero and ability IDs and other information provided by the API from the [dotaconstants](https://github.com/odota/dotaconstants) repository.  Without a key, you can make 2,000 free calls per day at a rate limit of 60 requests/minute. We also offer a Premium Tier with unlimited API calls and higher rate limits. Check out the [API page](https://www.opendota.com/api-keys) to learn more.     

API version: 25.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// HeroesAPIService HeroesAPI service
type HeroesAPIService service

type ApiGetHeroesRequest struct {
	ctx context.Context
	ApiService *HeroesAPIService
}

func (r ApiGetHeroesRequest) Execute() ([]HeroObjectResponse, *http.Response, error) {
	return r.ApiService.GetHeroesExecute(r)
}

/*
GetHeroes GET /heroes

Get hero data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHeroesRequest
*/
func (a *HeroesAPIService) GetHeroes(ctx context.Context) ApiGetHeroesRequest {
	return ApiGetHeroesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []HeroObjectResponse
func (a *HeroesAPIService) GetHeroesExecute(r ApiGetHeroesRequest) ([]HeroObjectResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HeroObjectResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeroesAPIService.GetHeroes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/heroes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHeroesByHeroIdSelectDurationsRequest struct {
	ctx context.Context
	ApiService *HeroesAPIService
	heroId int32
}

func (r ApiGetHeroesByHeroIdSelectDurationsRequest) Execute() ([]HeroDurationsResponse, *http.Response, error) {
	return r.ApiService.GetHeroesByHeroIdSelectDurationsExecute(r)
}

/*
GetHeroesByHeroIdSelectDurations GET /heroes/{hero_id}/durations

Get hero performance over a range of match durations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param heroId Hero ID
 @return ApiGetHeroesByHeroIdSelectDurationsRequest
*/
func (a *HeroesAPIService) GetHeroesByHeroIdSelectDurations(ctx context.Context, heroId int32) ApiGetHeroesByHeroIdSelectDurationsRequest {
	return ApiGetHeroesByHeroIdSelectDurationsRequest{
		ApiService: a,
		ctx: ctx,
		heroId: heroId,
	}
}

// Execute executes the request
//  @return []HeroDurationsResponse
func (a *HeroesAPIService) GetHeroesByHeroIdSelectDurationsExecute(r ApiGetHeroesByHeroIdSelectDurationsRequest) ([]HeroDurationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HeroDurationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeroesAPIService.GetHeroesByHeroIdSelectDurations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/heroes/{hero_id}/durations"
	localVarPath = strings.Replace(localVarPath, "{"+"hero_id"+"}", url.PathEscape(parameterValueToString(r.heroId, "heroId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHeroesByHeroIdSelectItemPopularityRequest struct {
	ctx context.Context
	ApiService *HeroesAPIService
	heroId int32
}

func (r ApiGetHeroesByHeroIdSelectItemPopularityRequest) Execute() (*HeroItemPopularityResponse, *http.Response, error) {
	return r.ApiService.GetHeroesByHeroIdSelectItemPopularityExecute(r)
}

/*
GetHeroesByHeroIdSelectItemPopularity GET /heroes/{hero_id}/itemPopularity

Get item popularity of hero categoried by start, early, mid and late game, analyzed from professional games

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param heroId Hero ID
 @return ApiGetHeroesByHeroIdSelectItemPopularityRequest
*/
func (a *HeroesAPIService) GetHeroesByHeroIdSelectItemPopularity(ctx context.Context, heroId int32) ApiGetHeroesByHeroIdSelectItemPopularityRequest {
	return ApiGetHeroesByHeroIdSelectItemPopularityRequest{
		ApiService: a,
		ctx: ctx,
		heroId: heroId,
	}
}

// Execute executes the request
//  @return HeroItemPopularityResponse
func (a *HeroesAPIService) GetHeroesByHeroIdSelectItemPopularityExecute(r ApiGetHeroesByHeroIdSelectItemPopularityRequest) (*HeroItemPopularityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HeroItemPopularityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeroesAPIService.GetHeroesByHeroIdSelectItemPopularity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/heroes/{hero_id}/itemPopularity"
	localVarPath = strings.Replace(localVarPath, "{"+"hero_id"+"}", url.PathEscape(parameterValueToString(r.heroId, "heroId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHeroesByHeroIdSelectMatchesRequest struct {
	ctx context.Context
	ApiService *HeroesAPIService
	heroId int32
}

func (r ApiGetHeroesByHeroIdSelectMatchesRequest) Execute() ([]MatchObjectResponse, *http.Response, error) {
	return r.ApiService.GetHeroesByHeroIdSelectMatchesExecute(r)
}

/*
GetHeroesByHeroIdSelectMatches GET /heroes/{hero_id}/matches

Get recent matches with a hero

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param heroId Hero ID
 @return ApiGetHeroesByHeroIdSelectMatchesRequest
*/
func (a *HeroesAPIService) GetHeroesByHeroIdSelectMatches(ctx context.Context, heroId int32) ApiGetHeroesByHeroIdSelectMatchesRequest {
	return ApiGetHeroesByHeroIdSelectMatchesRequest{
		ApiService: a,
		ctx: ctx,
		heroId: heroId,
	}
}

// Execute executes the request
//  @return []MatchObjectResponse
func (a *HeroesAPIService) GetHeroesByHeroIdSelectMatchesExecute(r ApiGetHeroesByHeroIdSelectMatchesRequest) ([]MatchObjectResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MatchObjectResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeroesAPIService.GetHeroesByHeroIdSelectMatches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/heroes/{hero_id}/matches"
	localVarPath = strings.Replace(localVarPath, "{"+"hero_id"+"}", url.PathEscape(parameterValueToString(r.heroId, "heroId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHeroesByHeroIdSelectMatchupsRequest struct {
	ctx context.Context
	ApiService *HeroesAPIService
	heroId int32
}

func (r ApiGetHeroesByHeroIdSelectMatchupsRequest) Execute() ([]HeroMatchupsResponse, *http.Response, error) {
	return r.ApiService.GetHeroesByHeroIdSelectMatchupsExecute(r)
}

/*
GetHeroesByHeroIdSelectMatchups GET /heroes/{hero_id}/matchups

Get results against other heroes for a hero

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param heroId Hero ID
 @return ApiGetHeroesByHeroIdSelectMatchupsRequest
*/
func (a *HeroesAPIService) GetHeroesByHeroIdSelectMatchups(ctx context.Context, heroId int32) ApiGetHeroesByHeroIdSelectMatchupsRequest {
	return ApiGetHeroesByHeroIdSelectMatchupsRequest{
		ApiService: a,
		ctx: ctx,
		heroId: heroId,
	}
}

// Execute executes the request
//  @return []HeroMatchupsResponse
func (a *HeroesAPIService) GetHeroesByHeroIdSelectMatchupsExecute(r ApiGetHeroesByHeroIdSelectMatchupsRequest) ([]HeroMatchupsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HeroMatchupsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeroesAPIService.GetHeroesByHeroIdSelectMatchups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/heroes/{hero_id}/matchups"
	localVarPath = strings.Replace(localVarPath, "{"+"hero_id"+"}", url.PathEscape(parameterValueToString(r.heroId, "heroId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHeroesByHeroIdSelectPlayersRequest struct {
	ctx context.Context
	ApiService *HeroesAPIService
	heroId int32
}

func (r ApiGetHeroesByHeroIdSelectPlayersRequest) Execute() ([][]PlayerObjectResponse, *http.Response, error) {
	return r.ApiService.GetHeroesByHeroIdSelectPlayersExecute(r)
}

/*
GetHeroesByHeroIdSelectPlayers GET /heroes/{hero_id}/players

Get players who have played this hero

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param heroId Hero ID
 @return ApiGetHeroesByHeroIdSelectPlayersRequest
*/
func (a *HeroesAPIService) GetHeroesByHeroIdSelectPlayers(ctx context.Context, heroId int32) ApiGetHeroesByHeroIdSelectPlayersRequest {
	return ApiGetHeroesByHeroIdSelectPlayersRequest{
		ApiService: a,
		ctx: ctx,
		heroId: heroId,
	}
}

// Execute executes the request
//  @return [][]PlayerObjectResponse
func (a *HeroesAPIService) GetHeroesByHeroIdSelectPlayersExecute(r ApiGetHeroesByHeroIdSelectPlayersRequest) ([][]PlayerObjectResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]PlayerObjectResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HeroesAPIService.GetHeroesByHeroIdSelectPlayers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/heroes/{hero_id}/players"
	localVarPath = strings.Replace(localVarPath, "{"+"hero_id"+"}", url.PathEscape(parameterValueToString(r.heroId, "heroId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

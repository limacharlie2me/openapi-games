/*
OpenDota API

# Introduction The OpenDota API provides Dota 2 related data including advanced match data extracted from match replays.  You can find data that can be used to convert hero and ability IDs and other information provided by the API from the [dotaconstants](https://github.com/odota/dotaconstants) repository.  Without a key, you can make 2,000 free calls per day at a rate limit of 60 requests/minute. We also offer a Premium Tier with unlimited API calls and higher rate limits. Check out the [API page](https://www.opendota.com/api-keys) to learn more.     

API version: 25.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ScenariosAPIService ScenariosAPI service
type ScenariosAPIService service

type ApiGetScenariosItemTimingsRequest struct {
	ctx context.Context
	ApiService *ScenariosAPIService
	item *string
	heroId *int32
}

// Filter by item name e.g. \&quot;spirit_vessel\&quot;
func (r ApiGetScenariosItemTimingsRequest) Item(item string) ApiGetScenariosItemTimingsRequest {
	r.item = &item
	return r
}

// Hero ID
func (r ApiGetScenariosItemTimingsRequest) HeroId(heroId int32) ApiGetScenariosItemTimingsRequest {
	r.heroId = &heroId
	return r
}

func (r ApiGetScenariosItemTimingsRequest) Execute() ([]ScenarioItemTimingsResponse, *http.Response, error) {
	return r.ApiService.GetScenariosItemTimingsExecute(r)
}

/*
GetScenariosItemTimings GET /scenarios/itemTimings

Win rates for certain item timings on a hero for items that cost at least 1400 gold

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetScenariosItemTimingsRequest
*/
func (a *ScenariosAPIService) GetScenariosItemTimings(ctx context.Context) ApiGetScenariosItemTimingsRequest {
	return ApiGetScenariosItemTimingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ScenarioItemTimingsResponse
func (a *ScenariosAPIService) GetScenariosItemTimingsExecute(r ApiGetScenariosItemTimingsRequest) ([]ScenarioItemTimingsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ScenarioItemTimingsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScenariosAPIService.GetScenariosItemTimings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scenarios/itemTimings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.item != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "item", r.item, "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetScenariosLaneRolesRequest struct {
	ctx context.Context
	ApiService *ScenariosAPIService
	laneRole *string
	heroId *int32
}

// Filter by lane role 1-4 (Safe, Mid, Off, Jungle)
func (r ApiGetScenariosLaneRolesRequest) LaneRole(laneRole string) ApiGetScenariosLaneRolesRequest {
	r.laneRole = &laneRole
	return r
}

// Hero ID
func (r ApiGetScenariosLaneRolesRequest) HeroId(heroId int32) ApiGetScenariosLaneRolesRequest {
	r.heroId = &heroId
	return r
}

func (r ApiGetScenariosLaneRolesRequest) Execute() ([]ScenarioLaneRolesResponse, *http.Response, error) {
	return r.ApiService.GetScenariosLaneRolesExecute(r)
}

/*
GetScenariosLaneRoles GET /scenarios/laneRoles

Win rates for heroes in certain lane roles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetScenariosLaneRolesRequest
*/
func (a *ScenariosAPIService) GetScenariosLaneRoles(ctx context.Context) ApiGetScenariosLaneRolesRequest {
	return ApiGetScenariosLaneRolesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ScenarioLaneRolesResponse
func (a *ScenariosAPIService) GetScenariosLaneRolesExecute(r ApiGetScenariosLaneRolesRequest) ([]ScenarioLaneRolesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ScenarioLaneRolesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScenariosAPIService.GetScenariosLaneRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scenarios/laneRoles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.laneRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lane_role", r.laneRole, "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetScenariosMiscRequest struct {
	ctx context.Context
	ApiService *ScenariosAPIService
	scenario *string
}

// Name of the scenario (see teamScenariosQueryParams)
func (r ApiGetScenariosMiscRequest) Scenario(scenario string) ApiGetScenariosMiscRequest {
	r.scenario = &scenario
	return r
}

func (r ApiGetScenariosMiscRequest) Execute() ([]ScenarioMiscResponse, *http.Response, error) {
	return r.ApiService.GetScenariosMiscExecute(r)
}

/*
GetScenariosMisc GET /scenarios/misc

Miscellaneous team scenarios

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetScenariosMiscRequest
*/
func (a *ScenariosAPIService) GetScenariosMisc(ctx context.Context) ApiGetScenariosMiscRequest {
	return ApiGetScenariosMiscRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ScenarioMiscResponse
func (a *ScenariosAPIService) GetScenariosMiscExecute(r ApiGetScenariosMiscRequest) ([]ScenarioMiscResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ScenarioMiscResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScenariosAPIService.GetScenariosMisc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scenarios/misc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scenario != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scenario", r.scenario, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

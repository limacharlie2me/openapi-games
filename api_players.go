/*
OpenDota API

# Introduction The OpenDota API provides Dota 2 related data including advanced match data extracted from match replays.  You can find data that can be used to convert hero and ability IDs and other information provided by the API from the [dotaconstants](https://github.com/odota/dotaconstants) repository.  Without a key, you can make 2,000 free calls per day at a rate limit of 60 requests/minute. We also offer a Premium Tier with unlimited API calls and higher rate limits. Check out the [API page](https://www.opendota.com/api-keys) to learn more.     

API version: 25.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PlayersAPIService PlayersAPI service
type PlayersAPIService service

type ApiGetPlayersByAccountIdRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
}

func (r ApiGetPlayersByAccountIdRequest) Execute() (*PlayersResponse, *http.Response, error) {
	return r.ApiService.GetPlayersByAccountIdExecute(r)
}

/*
GetPlayersByAccountId GET /players/{account_id}

Player data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @return ApiGetPlayersByAccountIdRequest
*/
func (a *PlayersAPIService) GetPlayersByAccountId(ctx context.Context, accountId int32) ApiGetPlayersByAccountIdRequest {
	return ApiGetPlayersByAccountIdRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return PlayersResponse
func (a *PlayersAPIService) GetPlayersByAccountIdExecute(r ApiGetPlayersByAccountIdRequest) (*PlayersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlayersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.GetPlayersByAccountId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlayersByAccountIdHistogramsByFieldRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
	field string
	limit *int32
	offset *int32
	win *int32
	patch *int32
	gameMode *int32
	lobbyType *int32
	region *int32
	date *int32
	laneRole *int32
	heroId *int32
	isRadiant *int32
	includedAccountId *int32
	excludedAccountId *int32
	withHeroId *int32
	againstHeroId *int32
	significant *int32
	having *int32
	sort *string
}

// Number of matches to limit to
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) Limit(limit int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.limit = &limit
	return r
}

// Number of matches to offset start by
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) Offset(offset int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.offset = &offset
	return r
}

// Whether the player won
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) Win(win int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.win = &win
	return r
}

// Patch ID, from dotaconstants
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) Patch(patch int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.patch = &patch
	return r
}

// Game Mode ID
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) GameMode(gameMode int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.gameMode = &gameMode
	return r
}

// Lobby type ID
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) LobbyType(lobbyType int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.lobbyType = &lobbyType
	return r
}

// Region ID
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) Region(region int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.region = &region
	return r
}

// Days previous
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) Date(date int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.date = &date
	return r
}

// Lane Role ID
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) LaneRole(laneRole int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.laneRole = &laneRole
	return r
}

// Hero ID
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) HeroId(heroId int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.heroId = &heroId
	return r
}

// Whether the player was radiant
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) IsRadiant(isRadiant int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.isRadiant = &isRadiant
	return r
}

// Account IDs in the match (array)
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) IncludedAccountId(includedAccountId int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.includedAccountId = &includedAccountId
	return r
}

// Account IDs not in the match (array)
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) ExcludedAccountId(excludedAccountId int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.excludedAccountId = &excludedAccountId
	return r
}

// Hero IDs on the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) WithHeroId(withHeroId int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.withHeroId = &withHeroId
	return r
}

// Hero IDs against the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) AgainstHeroId(againstHeroId int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.againstHeroId = &againstHeroId
	return r
}

// Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) Significant(significant int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.significant = &significant
	return r
}

// The minimum number of games played, for filtering hero stats
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) Having(having int32) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.having = &having
	return r
}

// The field to return matches sorted by in descending order
func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) Sort(sort string) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	r.sort = &sort
	return r
}

func (r ApiGetPlayersByAccountIdHistogramsByFieldRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPlayersByAccountIdHistogramsByFieldExecute(r)
}

/*
GetPlayersByAccountIdHistogramsByField GET /players/{account_id}/histograms

Distribution of matches in a single stat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @param field Field to aggregate on
 @return ApiGetPlayersByAccountIdHistogramsByFieldRequest
*/
func (a *PlayersAPIService) GetPlayersByAccountIdHistogramsByField(ctx context.Context, accountId int32, field string) ApiGetPlayersByAccountIdHistogramsByFieldRequest {
	return ApiGetPlayersByAccountIdHistogramsByFieldRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		field: field,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *PlayersAPIService) GetPlayersByAccountIdHistogramsByFieldExecute(r ApiGetPlayersByAccountIdHistogramsByFieldRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.GetPlayersByAccountIdHistogramsByField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}/histograms/{field}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"field"+"}", url.PathEscape(parameterValueToString(r.field, "field")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.win != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "win", r.win, "")
	}
	if r.patch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "patch", r.patch, "")
	}
	if r.gameMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "game_mode", r.gameMode, "")
	}
	if r.lobbyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lobby_type", r.lobbyType, "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.laneRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lane_role", r.laneRole, "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "")
	}
	if r.isRadiant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_radiant", r.isRadiant, "")
	}
	if r.includedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "included_account_id", r.includedAccountId, "")
	}
	if r.excludedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excluded_account_id", r.excludedAccountId, "")
	}
	if r.withHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_hero_id", r.withHeroId, "")
	}
	if r.againstHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "against_hero_id", r.againstHeroId, "")
	}
	if r.significant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "significant", r.significant, "")
	}
	if r.having != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "having", r.having, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlayersByAccountIdSelectCountsRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
	limit *int32
	offset *int32
	win *int32
	patch *int32
	gameMode *int32
	lobbyType *int32
	region *int32
	date *int32
	laneRole *int32
	heroId *int32
	isRadiant *int32
	includedAccountId *int32
	excludedAccountId *int32
	withHeroId *int32
	againstHeroId *int32
	significant *int32
	having *int32
	sort *string
}

// Number of matches to limit to
func (r ApiGetPlayersByAccountIdSelectCountsRequest) Limit(limit int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.limit = &limit
	return r
}

// Number of matches to offset start by
func (r ApiGetPlayersByAccountIdSelectCountsRequest) Offset(offset int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.offset = &offset
	return r
}

// Whether the player won
func (r ApiGetPlayersByAccountIdSelectCountsRequest) Win(win int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.win = &win
	return r
}

// Patch ID, from dotaconstants
func (r ApiGetPlayersByAccountIdSelectCountsRequest) Patch(patch int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.patch = &patch
	return r
}

// Game Mode ID
func (r ApiGetPlayersByAccountIdSelectCountsRequest) GameMode(gameMode int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.gameMode = &gameMode
	return r
}

// Lobby type ID
func (r ApiGetPlayersByAccountIdSelectCountsRequest) LobbyType(lobbyType int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.lobbyType = &lobbyType
	return r
}

// Region ID
func (r ApiGetPlayersByAccountIdSelectCountsRequest) Region(region int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.region = &region
	return r
}

// Days previous
func (r ApiGetPlayersByAccountIdSelectCountsRequest) Date(date int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.date = &date
	return r
}

// Lane Role ID
func (r ApiGetPlayersByAccountIdSelectCountsRequest) LaneRole(laneRole int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.laneRole = &laneRole
	return r
}

// Hero ID
func (r ApiGetPlayersByAccountIdSelectCountsRequest) HeroId(heroId int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.heroId = &heroId
	return r
}

// Whether the player was radiant
func (r ApiGetPlayersByAccountIdSelectCountsRequest) IsRadiant(isRadiant int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.isRadiant = &isRadiant
	return r
}

// Account IDs in the match (array)
func (r ApiGetPlayersByAccountIdSelectCountsRequest) IncludedAccountId(includedAccountId int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.includedAccountId = &includedAccountId
	return r
}

// Account IDs not in the match (array)
func (r ApiGetPlayersByAccountIdSelectCountsRequest) ExcludedAccountId(excludedAccountId int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.excludedAccountId = &excludedAccountId
	return r
}

// Hero IDs on the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectCountsRequest) WithHeroId(withHeroId int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.withHeroId = &withHeroId
	return r
}

// Hero IDs against the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectCountsRequest) AgainstHeroId(againstHeroId int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.againstHeroId = &againstHeroId
	return r
}

// Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
func (r ApiGetPlayersByAccountIdSelectCountsRequest) Significant(significant int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.significant = &significant
	return r
}

// The minimum number of games played, for filtering hero stats
func (r ApiGetPlayersByAccountIdSelectCountsRequest) Having(having int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.having = &having
	return r
}

// The field to return matches sorted by in descending order
func (r ApiGetPlayersByAccountIdSelectCountsRequest) Sort(sort string) ApiGetPlayersByAccountIdSelectCountsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetPlayersByAccountIdSelectCountsRequest) Execute() (*PlayerCountsResponse, *http.Response, error) {
	return r.ApiService.GetPlayersByAccountIdSelectCountsExecute(r)
}

/*
GetPlayersByAccountIdSelectCounts GET /players/{account_id}/counts

Counts in categories

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @return ApiGetPlayersByAccountIdSelectCountsRequest
*/
func (a *PlayersAPIService) GetPlayersByAccountIdSelectCounts(ctx context.Context, accountId int32) ApiGetPlayersByAccountIdSelectCountsRequest {
	return ApiGetPlayersByAccountIdSelectCountsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return PlayerCountsResponse
func (a *PlayersAPIService) GetPlayersByAccountIdSelectCountsExecute(r ApiGetPlayersByAccountIdSelectCountsRequest) (*PlayerCountsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlayerCountsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.GetPlayersByAccountIdSelectCounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}/counts"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.win != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "win", r.win, "")
	}
	if r.patch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "patch", r.patch, "")
	}
	if r.gameMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "game_mode", r.gameMode, "")
	}
	if r.lobbyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lobby_type", r.lobbyType, "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.laneRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lane_role", r.laneRole, "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "")
	}
	if r.isRadiant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_radiant", r.isRadiant, "")
	}
	if r.includedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "included_account_id", r.includedAccountId, "")
	}
	if r.excludedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excluded_account_id", r.excludedAccountId, "")
	}
	if r.withHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_hero_id", r.withHeroId, "")
	}
	if r.againstHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "against_hero_id", r.againstHeroId, "")
	}
	if r.significant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "significant", r.significant, "")
	}
	if r.having != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "having", r.having, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlayersByAccountIdSelectHeroesRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
	limit *int32
	offset *int32
	win *int32
	patch *int32
	gameMode *int32
	lobbyType *int32
	region *int32
	date *int32
	laneRole *int32
	heroId *int32
	isRadiant *int32
	includedAccountId *int32
	excludedAccountId *int32
	withHeroId *int32
	againstHeroId *int32
	significant *int32
	having *int32
	sort *string
}

// Number of matches to limit to
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) Limit(limit int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.limit = &limit
	return r
}

// Number of matches to offset start by
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) Offset(offset int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.offset = &offset
	return r
}

// Whether the player won
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) Win(win int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.win = &win
	return r
}

// Patch ID, from dotaconstants
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) Patch(patch int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.patch = &patch
	return r
}

// Game Mode ID
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) GameMode(gameMode int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.gameMode = &gameMode
	return r
}

// Lobby type ID
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) LobbyType(lobbyType int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.lobbyType = &lobbyType
	return r
}

// Region ID
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) Region(region int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.region = &region
	return r
}

// Days previous
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) Date(date int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.date = &date
	return r
}

// Lane Role ID
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) LaneRole(laneRole int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.laneRole = &laneRole
	return r
}

// Hero ID
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) HeroId(heroId int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.heroId = &heroId
	return r
}

// Whether the player was radiant
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) IsRadiant(isRadiant int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.isRadiant = &isRadiant
	return r
}

// Account IDs in the match (array)
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) IncludedAccountId(includedAccountId int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.includedAccountId = &includedAccountId
	return r
}

// Account IDs not in the match (array)
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) ExcludedAccountId(excludedAccountId int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.excludedAccountId = &excludedAccountId
	return r
}

// Hero IDs on the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) WithHeroId(withHeroId int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.withHeroId = &withHeroId
	return r
}

// Hero IDs against the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) AgainstHeroId(againstHeroId int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.againstHeroId = &againstHeroId
	return r
}

// Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) Significant(significant int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.significant = &significant
	return r
}

// The minimum number of games played, for filtering hero stats
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) Having(having int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.having = &having
	return r
}

// The field to return matches sorted by in descending order
func (r ApiGetPlayersByAccountIdSelectHeroesRequest) Sort(sort string) ApiGetPlayersByAccountIdSelectHeroesRequest {
	r.sort = &sort
	return r
}

func (r ApiGetPlayersByAccountIdSelectHeroesRequest) Execute() ([]PlayerHeroesResponse, *http.Response, error) {
	return r.ApiService.GetPlayersByAccountIdSelectHeroesExecute(r)
}

/*
GetPlayersByAccountIdSelectHeroes GET /players/{account_id}/heroes

Heroes played

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @return ApiGetPlayersByAccountIdSelectHeroesRequest
*/
func (a *PlayersAPIService) GetPlayersByAccountIdSelectHeroes(ctx context.Context, accountId int32) ApiGetPlayersByAccountIdSelectHeroesRequest {
	return ApiGetPlayersByAccountIdSelectHeroesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []PlayerHeroesResponse
func (a *PlayersAPIService) GetPlayersByAccountIdSelectHeroesExecute(r ApiGetPlayersByAccountIdSelectHeroesRequest) ([]PlayerHeroesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PlayerHeroesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.GetPlayersByAccountIdSelectHeroes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}/heroes"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.win != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "win", r.win, "")
	}
	if r.patch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "patch", r.patch, "")
	}
	if r.gameMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "game_mode", r.gameMode, "")
	}
	if r.lobbyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lobby_type", r.lobbyType, "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.laneRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lane_role", r.laneRole, "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "")
	}
	if r.isRadiant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_radiant", r.isRadiant, "")
	}
	if r.includedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "included_account_id", r.includedAccountId, "")
	}
	if r.excludedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excluded_account_id", r.excludedAccountId, "")
	}
	if r.withHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_hero_id", r.withHeroId, "")
	}
	if r.againstHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "against_hero_id", r.againstHeroId, "")
	}
	if r.significant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "significant", r.significant, "")
	}
	if r.having != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "having", r.having, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlayersByAccountIdSelectMatchesRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
	limit *int32
	offset *int32
	win *int32
	patch *int32
	gameMode *int32
	lobbyType *int32
	region *int32
	date *int32
	laneRole *int32
	heroId *int32
	isRadiant *int32
	includedAccountId *int32
	excludedAccountId *int32
	withHeroId *int32
	againstHeroId *int32
	significant *int32
	having *int32
	sort *string
	project *string
}

// Number of matches to limit to
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) Limit(limit int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.limit = &limit
	return r
}

// Number of matches to offset start by
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) Offset(offset int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.offset = &offset
	return r
}

// Whether the player won
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) Win(win int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.win = &win
	return r
}

// Patch ID, from dotaconstants
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) Patch(patch int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.patch = &patch
	return r
}

// Game Mode ID
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) GameMode(gameMode int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.gameMode = &gameMode
	return r
}

// Lobby type ID
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) LobbyType(lobbyType int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.lobbyType = &lobbyType
	return r
}

// Region ID
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) Region(region int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.region = &region
	return r
}

// Days previous
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) Date(date int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.date = &date
	return r
}

// Lane Role ID
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) LaneRole(laneRole int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.laneRole = &laneRole
	return r
}

// Hero ID
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) HeroId(heroId int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.heroId = &heroId
	return r
}

// Whether the player was radiant
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) IsRadiant(isRadiant int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.isRadiant = &isRadiant
	return r
}

// Account IDs in the match (array)
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) IncludedAccountId(includedAccountId int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.includedAccountId = &includedAccountId
	return r
}

// Account IDs not in the match (array)
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) ExcludedAccountId(excludedAccountId int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.excludedAccountId = &excludedAccountId
	return r
}

// Hero IDs on the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) WithHeroId(withHeroId int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.withHeroId = &withHeroId
	return r
}

// Hero IDs against the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) AgainstHeroId(againstHeroId int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.againstHeroId = &againstHeroId
	return r
}

// Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) Significant(significant int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.significant = &significant
	return r
}

// The minimum number of games played, for filtering hero stats
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) Having(having int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.having = &having
	return r
}

// The field to return matches sorted by in descending order
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) Sort(sort string) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.sort = &sort
	return r
}

// Fields to project (array)
func (r ApiGetPlayersByAccountIdSelectMatchesRequest) Project(project string) ApiGetPlayersByAccountIdSelectMatchesRequest {
	r.project = &project
	return r
}

func (r ApiGetPlayersByAccountIdSelectMatchesRequest) Execute() ([]PlayerMatchesResponse, *http.Response, error) {
	return r.ApiService.GetPlayersByAccountIdSelectMatchesExecute(r)
}

/*
GetPlayersByAccountIdSelectMatches GET /players/{account_id}/matches

Matches played

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @return ApiGetPlayersByAccountIdSelectMatchesRequest
*/
func (a *PlayersAPIService) GetPlayersByAccountIdSelectMatches(ctx context.Context, accountId int32) ApiGetPlayersByAccountIdSelectMatchesRequest {
	return ApiGetPlayersByAccountIdSelectMatchesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []PlayerMatchesResponse
func (a *PlayersAPIService) GetPlayersByAccountIdSelectMatchesExecute(r ApiGetPlayersByAccountIdSelectMatchesRequest) ([]PlayerMatchesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PlayerMatchesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.GetPlayersByAccountIdSelectMatches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}/matches"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.win != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "win", r.win, "")
	}
	if r.patch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "patch", r.patch, "")
	}
	if r.gameMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "game_mode", r.gameMode, "")
	}
	if r.lobbyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lobby_type", r.lobbyType, "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.laneRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lane_role", r.laneRole, "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "")
	}
	if r.isRadiant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_radiant", r.isRadiant, "")
	}
	if r.includedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "included_account_id", r.includedAccountId, "")
	}
	if r.excludedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excluded_account_id", r.excludedAccountId, "")
	}
	if r.withHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_hero_id", r.withHeroId, "")
	}
	if r.againstHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "against_hero_id", r.againstHeroId, "")
	}
	if r.significant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "significant", r.significant, "")
	}
	if r.having != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "having", r.having, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.project != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "project", r.project, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlayersByAccountIdSelectPeersRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
	limit *int32
	offset *int32
	win *int32
	patch *int32
	gameMode *int32
	lobbyType *int32
	region *int32
	date *int32
	laneRole *int32
	heroId *int32
	isRadiant *int32
	includedAccountId *int32
	excludedAccountId *int32
	withHeroId *int32
	againstHeroId *int32
	significant *int32
	having *int32
	sort *string
}

// Number of matches to limit to
func (r ApiGetPlayersByAccountIdSelectPeersRequest) Limit(limit int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.limit = &limit
	return r
}

// Number of matches to offset start by
func (r ApiGetPlayersByAccountIdSelectPeersRequest) Offset(offset int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.offset = &offset
	return r
}

// Whether the player won
func (r ApiGetPlayersByAccountIdSelectPeersRequest) Win(win int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.win = &win
	return r
}

// Patch ID, from dotaconstants
func (r ApiGetPlayersByAccountIdSelectPeersRequest) Patch(patch int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.patch = &patch
	return r
}

// Game Mode ID
func (r ApiGetPlayersByAccountIdSelectPeersRequest) GameMode(gameMode int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.gameMode = &gameMode
	return r
}

// Lobby type ID
func (r ApiGetPlayersByAccountIdSelectPeersRequest) LobbyType(lobbyType int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.lobbyType = &lobbyType
	return r
}

// Region ID
func (r ApiGetPlayersByAccountIdSelectPeersRequest) Region(region int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.region = &region
	return r
}

// Days previous
func (r ApiGetPlayersByAccountIdSelectPeersRequest) Date(date int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.date = &date
	return r
}

// Lane Role ID
func (r ApiGetPlayersByAccountIdSelectPeersRequest) LaneRole(laneRole int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.laneRole = &laneRole
	return r
}

// Hero ID
func (r ApiGetPlayersByAccountIdSelectPeersRequest) HeroId(heroId int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.heroId = &heroId
	return r
}

// Whether the player was radiant
func (r ApiGetPlayersByAccountIdSelectPeersRequest) IsRadiant(isRadiant int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.isRadiant = &isRadiant
	return r
}

// Account IDs in the match (array)
func (r ApiGetPlayersByAccountIdSelectPeersRequest) IncludedAccountId(includedAccountId int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.includedAccountId = &includedAccountId
	return r
}

// Account IDs not in the match (array)
func (r ApiGetPlayersByAccountIdSelectPeersRequest) ExcludedAccountId(excludedAccountId int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.excludedAccountId = &excludedAccountId
	return r
}

// Hero IDs on the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectPeersRequest) WithHeroId(withHeroId int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.withHeroId = &withHeroId
	return r
}

// Hero IDs against the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectPeersRequest) AgainstHeroId(againstHeroId int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.againstHeroId = &againstHeroId
	return r
}

// Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
func (r ApiGetPlayersByAccountIdSelectPeersRequest) Significant(significant int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.significant = &significant
	return r
}

// The minimum number of games played, for filtering hero stats
func (r ApiGetPlayersByAccountIdSelectPeersRequest) Having(having int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.having = &having
	return r
}

// The field to return matches sorted by in descending order
func (r ApiGetPlayersByAccountIdSelectPeersRequest) Sort(sort string) ApiGetPlayersByAccountIdSelectPeersRequest {
	r.sort = &sort
	return r
}

func (r ApiGetPlayersByAccountIdSelectPeersRequest) Execute() ([]PlayerPeersResponse, *http.Response, error) {
	return r.ApiService.GetPlayersByAccountIdSelectPeersExecute(r)
}

/*
GetPlayersByAccountIdSelectPeers GET /players/{account_id}/peers

Players played with

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @return ApiGetPlayersByAccountIdSelectPeersRequest
*/
func (a *PlayersAPIService) GetPlayersByAccountIdSelectPeers(ctx context.Context, accountId int32) ApiGetPlayersByAccountIdSelectPeersRequest {
	return ApiGetPlayersByAccountIdSelectPeersRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []PlayerPeersResponse
func (a *PlayersAPIService) GetPlayersByAccountIdSelectPeersExecute(r ApiGetPlayersByAccountIdSelectPeersRequest) ([]PlayerPeersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PlayerPeersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.GetPlayersByAccountIdSelectPeers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}/peers"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.win != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "win", r.win, "")
	}
	if r.patch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "patch", r.patch, "")
	}
	if r.gameMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "game_mode", r.gameMode, "")
	}
	if r.lobbyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lobby_type", r.lobbyType, "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.laneRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lane_role", r.laneRole, "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "")
	}
	if r.isRadiant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_radiant", r.isRadiant, "")
	}
	if r.includedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "included_account_id", r.includedAccountId, "")
	}
	if r.excludedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excluded_account_id", r.excludedAccountId, "")
	}
	if r.withHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_hero_id", r.withHeroId, "")
	}
	if r.againstHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "against_hero_id", r.againstHeroId, "")
	}
	if r.significant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "significant", r.significant, "")
	}
	if r.having != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "having", r.having, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlayersByAccountIdSelectProsRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
	limit *int32
	offset *int32
	win *int32
	patch *int32
	gameMode *int32
	lobbyType *int32
	region *int32
	date *int32
	laneRole *int32
	heroId *int32
	isRadiant *int32
	includedAccountId *int32
	excludedAccountId *int32
	withHeroId *int32
	againstHeroId *int32
	significant *int32
	having *int32
	sort *string
}

// Number of matches to limit to
func (r ApiGetPlayersByAccountIdSelectProsRequest) Limit(limit int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.limit = &limit
	return r
}

// Number of matches to offset start by
func (r ApiGetPlayersByAccountIdSelectProsRequest) Offset(offset int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.offset = &offset
	return r
}

// Whether the player won
func (r ApiGetPlayersByAccountIdSelectProsRequest) Win(win int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.win = &win
	return r
}

// Patch ID, from dotaconstants
func (r ApiGetPlayersByAccountIdSelectProsRequest) Patch(patch int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.patch = &patch
	return r
}

// Game Mode ID
func (r ApiGetPlayersByAccountIdSelectProsRequest) GameMode(gameMode int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.gameMode = &gameMode
	return r
}

// Lobby type ID
func (r ApiGetPlayersByAccountIdSelectProsRequest) LobbyType(lobbyType int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.lobbyType = &lobbyType
	return r
}

// Region ID
func (r ApiGetPlayersByAccountIdSelectProsRequest) Region(region int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.region = &region
	return r
}

// Days previous
func (r ApiGetPlayersByAccountIdSelectProsRequest) Date(date int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.date = &date
	return r
}

// Lane Role ID
func (r ApiGetPlayersByAccountIdSelectProsRequest) LaneRole(laneRole int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.laneRole = &laneRole
	return r
}

// Hero ID
func (r ApiGetPlayersByAccountIdSelectProsRequest) HeroId(heroId int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.heroId = &heroId
	return r
}

// Whether the player was radiant
func (r ApiGetPlayersByAccountIdSelectProsRequest) IsRadiant(isRadiant int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.isRadiant = &isRadiant
	return r
}

// Account IDs in the match (array)
func (r ApiGetPlayersByAccountIdSelectProsRequest) IncludedAccountId(includedAccountId int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.includedAccountId = &includedAccountId
	return r
}

// Account IDs not in the match (array)
func (r ApiGetPlayersByAccountIdSelectProsRequest) ExcludedAccountId(excludedAccountId int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.excludedAccountId = &excludedAccountId
	return r
}

// Hero IDs on the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectProsRequest) WithHeroId(withHeroId int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.withHeroId = &withHeroId
	return r
}

// Hero IDs against the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectProsRequest) AgainstHeroId(againstHeroId int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.againstHeroId = &againstHeroId
	return r
}

// Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
func (r ApiGetPlayersByAccountIdSelectProsRequest) Significant(significant int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.significant = &significant
	return r
}

// The minimum number of games played, for filtering hero stats
func (r ApiGetPlayersByAccountIdSelectProsRequest) Having(having int32) ApiGetPlayersByAccountIdSelectProsRequest {
	r.having = &having
	return r
}

// The field to return matches sorted by in descending order
func (r ApiGetPlayersByAccountIdSelectProsRequest) Sort(sort string) ApiGetPlayersByAccountIdSelectProsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetPlayersByAccountIdSelectProsRequest) Execute() ([]PlayerProsResponse, *http.Response, error) {
	return r.ApiService.GetPlayersByAccountIdSelectProsExecute(r)
}

/*
GetPlayersByAccountIdSelectPros GET /players/{account_id}/pros

Pro players played with

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @return ApiGetPlayersByAccountIdSelectProsRequest
*/
func (a *PlayersAPIService) GetPlayersByAccountIdSelectPros(ctx context.Context, accountId int32) ApiGetPlayersByAccountIdSelectProsRequest {
	return ApiGetPlayersByAccountIdSelectProsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []PlayerProsResponse
func (a *PlayersAPIService) GetPlayersByAccountIdSelectProsExecute(r ApiGetPlayersByAccountIdSelectProsRequest) ([]PlayerProsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PlayerProsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.GetPlayersByAccountIdSelectPros")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}/pros"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.win != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "win", r.win, "")
	}
	if r.patch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "patch", r.patch, "")
	}
	if r.gameMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "game_mode", r.gameMode, "")
	}
	if r.lobbyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lobby_type", r.lobbyType, "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.laneRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lane_role", r.laneRole, "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "")
	}
	if r.isRadiant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_radiant", r.isRadiant, "")
	}
	if r.includedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "included_account_id", r.includedAccountId, "")
	}
	if r.excludedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excluded_account_id", r.excludedAccountId, "")
	}
	if r.withHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_hero_id", r.withHeroId, "")
	}
	if r.againstHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "against_hero_id", r.againstHeroId, "")
	}
	if r.significant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "significant", r.significant, "")
	}
	if r.having != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "having", r.having, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlayersByAccountIdSelectRankingsRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
}

func (r ApiGetPlayersByAccountIdSelectRankingsRequest) Execute() ([]PlayerRankingsResponse, *http.Response, error) {
	return r.ApiService.GetPlayersByAccountIdSelectRankingsExecute(r)
}

/*
GetPlayersByAccountIdSelectRankings GET /players/{account_id}/rankings

Player hero rankings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @return ApiGetPlayersByAccountIdSelectRankingsRequest
*/
func (a *PlayersAPIService) GetPlayersByAccountIdSelectRankings(ctx context.Context, accountId int32) ApiGetPlayersByAccountIdSelectRankingsRequest {
	return ApiGetPlayersByAccountIdSelectRankingsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []PlayerRankingsResponse
func (a *PlayersAPIService) GetPlayersByAccountIdSelectRankingsExecute(r ApiGetPlayersByAccountIdSelectRankingsRequest) ([]PlayerRankingsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PlayerRankingsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.GetPlayersByAccountIdSelectRankings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}/rankings"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlayersByAccountIdSelectRatingsRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
}

func (r ApiGetPlayersByAccountIdSelectRatingsRequest) Execute() ([]PlayerRatingsResponse, *http.Response, error) {
	return r.ApiService.GetPlayersByAccountIdSelectRatingsExecute(r)
}

/*
GetPlayersByAccountIdSelectRatings GET /players/{account_id}/ratings

Player rating history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @return ApiGetPlayersByAccountIdSelectRatingsRequest
*/
func (a *PlayersAPIService) GetPlayersByAccountIdSelectRatings(ctx context.Context, accountId int32) ApiGetPlayersByAccountIdSelectRatingsRequest {
	return ApiGetPlayersByAccountIdSelectRatingsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []PlayerRatingsResponse
func (a *PlayersAPIService) GetPlayersByAccountIdSelectRatingsExecute(r ApiGetPlayersByAccountIdSelectRatingsRequest) ([]PlayerRatingsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PlayerRatingsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.GetPlayersByAccountIdSelectRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}/ratings"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlayersByAccountIdSelectRecentMatchesRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
}

func (r ApiGetPlayersByAccountIdSelectRecentMatchesRequest) Execute() ([][]PlayerRecentMatchesResponse, *http.Response, error) {
	return r.ApiService.GetPlayersByAccountIdSelectRecentMatchesExecute(r)
}

/*
GetPlayersByAccountIdSelectRecentMatches GET /players/{account_id}/recentMatches

Recent matches played

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @return ApiGetPlayersByAccountIdSelectRecentMatchesRequest
*/
func (a *PlayersAPIService) GetPlayersByAccountIdSelectRecentMatches(ctx context.Context, accountId int32) ApiGetPlayersByAccountIdSelectRecentMatchesRequest {
	return ApiGetPlayersByAccountIdSelectRecentMatchesRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return [][]PlayerRecentMatchesResponse
func (a *PlayersAPIService) GetPlayersByAccountIdSelectRecentMatchesExecute(r ApiGetPlayersByAccountIdSelectRecentMatchesRequest) ([][]PlayerRecentMatchesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]PlayerRecentMatchesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.GetPlayersByAccountIdSelectRecentMatches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}/recentMatches"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlayersByAccountIdSelectTotalsRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
	limit *int32
	offset *int32
	win *int32
	patch *int32
	gameMode *int32
	lobbyType *int32
	region *int32
	date *int32
	laneRole *int32
	heroId *int32
	isRadiant *int32
	includedAccountId *int32
	excludedAccountId *int32
	withHeroId *int32
	againstHeroId *int32
	significant *int32
	having *int32
	sort *string
}

// Number of matches to limit to
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) Limit(limit int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.limit = &limit
	return r
}

// Number of matches to offset start by
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) Offset(offset int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.offset = &offset
	return r
}

// Whether the player won
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) Win(win int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.win = &win
	return r
}

// Patch ID, from dotaconstants
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) Patch(patch int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.patch = &patch
	return r
}

// Game Mode ID
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) GameMode(gameMode int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.gameMode = &gameMode
	return r
}

// Lobby type ID
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) LobbyType(lobbyType int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.lobbyType = &lobbyType
	return r
}

// Region ID
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) Region(region int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.region = &region
	return r
}

// Days previous
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) Date(date int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.date = &date
	return r
}

// Lane Role ID
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) LaneRole(laneRole int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.laneRole = &laneRole
	return r
}

// Hero ID
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) HeroId(heroId int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.heroId = &heroId
	return r
}

// Whether the player was radiant
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) IsRadiant(isRadiant int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.isRadiant = &isRadiant
	return r
}

// Account IDs in the match (array)
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) IncludedAccountId(includedAccountId int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.includedAccountId = &includedAccountId
	return r
}

// Account IDs not in the match (array)
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) ExcludedAccountId(excludedAccountId int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.excludedAccountId = &excludedAccountId
	return r
}

// Hero IDs on the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) WithHeroId(withHeroId int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.withHeroId = &withHeroId
	return r
}

// Hero IDs against the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) AgainstHeroId(againstHeroId int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.againstHeroId = &againstHeroId
	return r
}

// Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) Significant(significant int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.significant = &significant
	return r
}

// The minimum number of games played, for filtering hero stats
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) Having(having int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.having = &having
	return r
}

// The field to return matches sorted by in descending order
func (r ApiGetPlayersByAccountIdSelectTotalsRequest) Sort(sort string) ApiGetPlayersByAccountIdSelectTotalsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetPlayersByAccountIdSelectTotalsRequest) Execute() ([]PlayerTotalsResponse, *http.Response, error) {
	return r.ApiService.GetPlayersByAccountIdSelectTotalsExecute(r)
}

/*
GetPlayersByAccountIdSelectTotals GET /players/{account_id}/totals

Totals in stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @return ApiGetPlayersByAccountIdSelectTotalsRequest
*/
func (a *PlayersAPIService) GetPlayersByAccountIdSelectTotals(ctx context.Context, accountId int32) ApiGetPlayersByAccountIdSelectTotalsRequest {
	return ApiGetPlayersByAccountIdSelectTotalsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []PlayerTotalsResponse
func (a *PlayersAPIService) GetPlayersByAccountIdSelectTotalsExecute(r ApiGetPlayersByAccountIdSelectTotalsRequest) ([]PlayerTotalsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PlayerTotalsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.GetPlayersByAccountIdSelectTotals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}/totals"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.win != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "win", r.win, "")
	}
	if r.patch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "patch", r.patch, "")
	}
	if r.gameMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "game_mode", r.gameMode, "")
	}
	if r.lobbyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lobby_type", r.lobbyType, "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.laneRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lane_role", r.laneRole, "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "")
	}
	if r.isRadiant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_radiant", r.isRadiant, "")
	}
	if r.includedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "included_account_id", r.includedAccountId, "")
	}
	if r.excludedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excluded_account_id", r.excludedAccountId, "")
	}
	if r.withHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_hero_id", r.withHeroId, "")
	}
	if r.againstHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "against_hero_id", r.againstHeroId, "")
	}
	if r.significant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "significant", r.significant, "")
	}
	if r.having != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "having", r.having, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlayersByAccountIdSelectWardmapRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
	limit *int32
	offset *int32
	win *int32
	patch *int32
	gameMode *int32
	lobbyType *int32
	region *int32
	date *int32
	laneRole *int32
	heroId *int32
	isRadiant *int32
	includedAccountId *int32
	excludedAccountId *int32
	withHeroId *int32
	againstHeroId *int32
	significant *int32
	having *int32
	sort *string
}

// Number of matches to limit to
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) Limit(limit int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.limit = &limit
	return r
}

// Number of matches to offset start by
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) Offset(offset int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.offset = &offset
	return r
}

// Whether the player won
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) Win(win int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.win = &win
	return r
}

// Patch ID, from dotaconstants
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) Patch(patch int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.patch = &patch
	return r
}

// Game Mode ID
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) GameMode(gameMode int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.gameMode = &gameMode
	return r
}

// Lobby type ID
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) LobbyType(lobbyType int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.lobbyType = &lobbyType
	return r
}

// Region ID
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) Region(region int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.region = &region
	return r
}

// Days previous
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) Date(date int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.date = &date
	return r
}

// Lane Role ID
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) LaneRole(laneRole int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.laneRole = &laneRole
	return r
}

// Hero ID
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) HeroId(heroId int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.heroId = &heroId
	return r
}

// Whether the player was radiant
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) IsRadiant(isRadiant int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.isRadiant = &isRadiant
	return r
}

// Account IDs in the match (array)
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) IncludedAccountId(includedAccountId int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.includedAccountId = &includedAccountId
	return r
}

// Account IDs not in the match (array)
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) ExcludedAccountId(excludedAccountId int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.excludedAccountId = &excludedAccountId
	return r
}

// Hero IDs on the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) WithHeroId(withHeroId int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.withHeroId = &withHeroId
	return r
}

// Hero IDs against the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) AgainstHeroId(againstHeroId int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.againstHeroId = &againstHeroId
	return r
}

// Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) Significant(significant int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.significant = &significant
	return r
}

// The minimum number of games played, for filtering hero stats
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) Having(having int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.having = &having
	return r
}

// The field to return matches sorted by in descending order
func (r ApiGetPlayersByAccountIdSelectWardmapRequest) Sort(sort string) ApiGetPlayersByAccountIdSelectWardmapRequest {
	r.sort = &sort
	return r
}

func (r ApiGetPlayersByAccountIdSelectWardmapRequest) Execute() (*PlayerWardMapResponse, *http.Response, error) {
	return r.ApiService.GetPlayersByAccountIdSelectWardmapExecute(r)
}

/*
GetPlayersByAccountIdSelectWardmap GET /players/{account_id}/wardmap

Wards placed in matches played

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @return ApiGetPlayersByAccountIdSelectWardmapRequest
*/
func (a *PlayersAPIService) GetPlayersByAccountIdSelectWardmap(ctx context.Context, accountId int32) ApiGetPlayersByAccountIdSelectWardmapRequest {
	return ApiGetPlayersByAccountIdSelectWardmapRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return PlayerWardMapResponse
func (a *PlayersAPIService) GetPlayersByAccountIdSelectWardmapExecute(r ApiGetPlayersByAccountIdSelectWardmapRequest) (*PlayerWardMapResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlayerWardMapResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.GetPlayersByAccountIdSelectWardmap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}/wardmap"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.win != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "win", r.win, "")
	}
	if r.patch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "patch", r.patch, "")
	}
	if r.gameMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "game_mode", r.gameMode, "")
	}
	if r.lobbyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lobby_type", r.lobbyType, "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.laneRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lane_role", r.laneRole, "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "")
	}
	if r.isRadiant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_radiant", r.isRadiant, "")
	}
	if r.includedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "included_account_id", r.includedAccountId, "")
	}
	if r.excludedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excluded_account_id", r.excludedAccountId, "")
	}
	if r.withHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_hero_id", r.withHeroId, "")
	}
	if r.againstHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "against_hero_id", r.againstHeroId, "")
	}
	if r.significant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "significant", r.significant, "")
	}
	if r.having != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "having", r.having, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlayersByAccountIdSelectWlRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
	limit *int32
	offset *int32
	win *int32
	patch *int32
	gameMode *int32
	lobbyType *int32
	region *int32
	date *int32
	laneRole *int32
	heroId *int32
	isRadiant *int32
	includedAccountId *int32
	excludedAccountId *int32
	withHeroId *int32
	againstHeroId *int32
	significant *int32
	having *int32
	sort *string
}

// Number of matches to limit to
func (r ApiGetPlayersByAccountIdSelectWlRequest) Limit(limit int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.limit = &limit
	return r
}

// Number of matches to offset start by
func (r ApiGetPlayersByAccountIdSelectWlRequest) Offset(offset int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.offset = &offset
	return r
}

// Whether the player won
func (r ApiGetPlayersByAccountIdSelectWlRequest) Win(win int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.win = &win
	return r
}

// Patch ID, from dotaconstants
func (r ApiGetPlayersByAccountIdSelectWlRequest) Patch(patch int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.patch = &patch
	return r
}

// Game Mode ID
func (r ApiGetPlayersByAccountIdSelectWlRequest) GameMode(gameMode int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.gameMode = &gameMode
	return r
}

// Lobby type ID
func (r ApiGetPlayersByAccountIdSelectWlRequest) LobbyType(lobbyType int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.lobbyType = &lobbyType
	return r
}

// Region ID
func (r ApiGetPlayersByAccountIdSelectWlRequest) Region(region int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.region = &region
	return r
}

// Days previous
func (r ApiGetPlayersByAccountIdSelectWlRequest) Date(date int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.date = &date
	return r
}

// Lane Role ID
func (r ApiGetPlayersByAccountIdSelectWlRequest) LaneRole(laneRole int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.laneRole = &laneRole
	return r
}

// Hero ID
func (r ApiGetPlayersByAccountIdSelectWlRequest) HeroId(heroId int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.heroId = &heroId
	return r
}

// Whether the player was radiant
func (r ApiGetPlayersByAccountIdSelectWlRequest) IsRadiant(isRadiant int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.isRadiant = &isRadiant
	return r
}

// Account IDs in the match (array)
func (r ApiGetPlayersByAccountIdSelectWlRequest) IncludedAccountId(includedAccountId int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.includedAccountId = &includedAccountId
	return r
}

// Account IDs not in the match (array)
func (r ApiGetPlayersByAccountIdSelectWlRequest) ExcludedAccountId(excludedAccountId int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.excludedAccountId = &excludedAccountId
	return r
}

// Hero IDs on the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectWlRequest) WithHeroId(withHeroId int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.withHeroId = &withHeroId
	return r
}

// Hero IDs against the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectWlRequest) AgainstHeroId(againstHeroId int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.againstHeroId = &againstHeroId
	return r
}

// Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
func (r ApiGetPlayersByAccountIdSelectWlRequest) Significant(significant int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.significant = &significant
	return r
}

// The minimum number of games played, for filtering hero stats
func (r ApiGetPlayersByAccountIdSelectWlRequest) Having(having int32) ApiGetPlayersByAccountIdSelectWlRequest {
	r.having = &having
	return r
}

// The field to return matches sorted by in descending order
func (r ApiGetPlayersByAccountIdSelectWlRequest) Sort(sort string) ApiGetPlayersByAccountIdSelectWlRequest {
	r.sort = &sort
	return r
}

func (r ApiGetPlayersByAccountIdSelectWlRequest) Execute() (*PlayerWinLossResponse, *http.Response, error) {
	return r.ApiService.GetPlayersByAccountIdSelectWlExecute(r)
}

/*
GetPlayersByAccountIdSelectWl GET /players/{account_id}/wl

Win/Loss count

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @return ApiGetPlayersByAccountIdSelectWlRequest
*/
func (a *PlayersAPIService) GetPlayersByAccountIdSelectWl(ctx context.Context, accountId int32) ApiGetPlayersByAccountIdSelectWlRequest {
	return ApiGetPlayersByAccountIdSelectWlRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return PlayerWinLossResponse
func (a *PlayersAPIService) GetPlayersByAccountIdSelectWlExecute(r ApiGetPlayersByAccountIdSelectWlRequest) (*PlayerWinLossResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlayerWinLossResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.GetPlayersByAccountIdSelectWl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}/wl"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.win != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "win", r.win, "")
	}
	if r.patch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "patch", r.patch, "")
	}
	if r.gameMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "game_mode", r.gameMode, "")
	}
	if r.lobbyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lobby_type", r.lobbyType, "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.laneRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lane_role", r.laneRole, "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "")
	}
	if r.isRadiant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_radiant", r.isRadiant, "")
	}
	if r.includedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "included_account_id", r.includedAccountId, "")
	}
	if r.excludedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excluded_account_id", r.excludedAccountId, "")
	}
	if r.withHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_hero_id", r.withHeroId, "")
	}
	if r.againstHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "against_hero_id", r.againstHeroId, "")
	}
	if r.significant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "significant", r.significant, "")
	}
	if r.having != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "having", r.having, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlayersByAccountIdSelectWordcloudRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
	limit *int32
	offset *int32
	win *int32
	patch *int32
	gameMode *int32
	lobbyType *int32
	region *int32
	date *int32
	laneRole *int32
	heroId *int32
	isRadiant *int32
	includedAccountId *int32
	excludedAccountId *int32
	withHeroId *int32
	againstHeroId *int32
	significant *int32
	having *int32
	sort *string
}

// Number of matches to limit to
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) Limit(limit int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.limit = &limit
	return r
}

// Number of matches to offset start by
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) Offset(offset int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.offset = &offset
	return r
}

// Whether the player won
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) Win(win int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.win = &win
	return r
}

// Patch ID, from dotaconstants
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) Patch(patch int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.patch = &patch
	return r
}

// Game Mode ID
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) GameMode(gameMode int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.gameMode = &gameMode
	return r
}

// Lobby type ID
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) LobbyType(lobbyType int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.lobbyType = &lobbyType
	return r
}

// Region ID
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) Region(region int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.region = &region
	return r
}

// Days previous
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) Date(date int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.date = &date
	return r
}

// Lane Role ID
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) LaneRole(laneRole int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.laneRole = &laneRole
	return r
}

// Hero ID
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) HeroId(heroId int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.heroId = &heroId
	return r
}

// Whether the player was radiant
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) IsRadiant(isRadiant int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.isRadiant = &isRadiant
	return r
}

// Account IDs in the match (array)
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) IncludedAccountId(includedAccountId int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.includedAccountId = &includedAccountId
	return r
}

// Account IDs not in the match (array)
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) ExcludedAccountId(excludedAccountId int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.excludedAccountId = &excludedAccountId
	return r
}

// Hero IDs on the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) WithHeroId(withHeroId int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.withHeroId = &withHeroId
	return r
}

// Hero IDs against the player&#39;s team (array)
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) AgainstHeroId(againstHeroId int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.againstHeroId = &againstHeroId
	return r
}

// Whether the match was significant for aggregation purposes. Defaults to 1 (true), set this to 0 to return data for non-standard modes/matches.
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) Significant(significant int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.significant = &significant
	return r
}

// The minimum number of games played, for filtering hero stats
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) Having(having int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.having = &having
	return r
}

// The field to return matches sorted by in descending order
func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) Sort(sort string) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	r.sort = &sort
	return r
}

func (r ApiGetPlayersByAccountIdSelectWordcloudRequest) Execute() (*PlayerWordCloudResponse, *http.Response, error) {
	return r.ApiService.GetPlayersByAccountIdSelectWordcloudExecute(r)
}

/*
GetPlayersByAccountIdSelectWordcloud GET /players/{account_id}/wordcloud

Words said/read in matches played

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @return ApiGetPlayersByAccountIdSelectWordcloudRequest
*/
func (a *PlayersAPIService) GetPlayersByAccountIdSelectWordcloud(ctx context.Context, accountId int32) ApiGetPlayersByAccountIdSelectWordcloudRequest {
	return ApiGetPlayersByAccountIdSelectWordcloudRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return PlayerWordCloudResponse
func (a *PlayersAPIService) GetPlayersByAccountIdSelectWordcloudExecute(r ApiGetPlayersByAccountIdSelectWordcloudRequest) (*PlayerWordCloudResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlayerWordCloudResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.GetPlayersByAccountIdSelectWordcloud")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}/wordcloud"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.win != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "win", r.win, "")
	}
	if r.patch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "patch", r.patch, "")
	}
	if r.gameMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "game_mode", r.gameMode, "")
	}
	if r.lobbyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lobby_type", r.lobbyType, "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.laneRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lane_role", r.laneRole, "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "")
	}
	if r.isRadiant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_radiant", r.isRadiant, "")
	}
	if r.includedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "included_account_id", r.includedAccountId, "")
	}
	if r.excludedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excluded_account_id", r.excludedAccountId, "")
	}
	if r.withHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_hero_id", r.withHeroId, "")
	}
	if r.againstHeroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "against_hero_id", r.againstHeroId, "")
	}
	if r.significant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "significant", r.significant, "")
	}
	if r.having != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "having", r.having, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRefreshRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
}

func (r ApiPostRefreshRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostRefreshExecute(r)
}

/*
PostRefresh POST /players/{account_id}/refresh

Refresh player match history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Steam32 account ID
 @return ApiPostRefreshRequest
*/
func (a *PlayersAPIService) PostRefresh(ctx context.Context, accountId int32) ApiPostRefreshRequest {
	return ApiPostRefreshRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlayersAPIService) PostRefreshExecute(r ApiPostRefreshRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.PostRefresh")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/players/{account_id}/refresh"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
